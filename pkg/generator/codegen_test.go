package generator

import (
	"context"
	"fmt"
	"os"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/spf13/afero"

	"github.com/Huang-Wei/25-kubecon-jp-codegen/pkg/internal"
	"github.com/Huang-Wei/25-kubecon-jp/go/generated/infra/account"
	"github.com/Huang-Wei/25-kubecon-jp/go/generated/tenant/resource"
	"github.com/Huang-Wei/25-kubecon-jp/go/generated/tenant/selector"
	"github.com/Huang-Wei/25-kubecon-jp/go/generated/tenant/selector/key"
	"github.com/Huang-Wei/25-kubecon-jp/go/generated/tenant/selector/operator"
)

func TestFanOutArtifacts(t *testing.T) {
	tests := []struct {
		name             string
		accounts         []*account.Account
		tenantTuples     []*internal.TenantTuple
		wantFiles        []string
		wantFileContents map[string]string
		wantErr          bool
	}{
		{
			name: "one account maps to one tenant",
			accounts: []*account.Account{
				{
					AccountID:     "1234",
					CloudProvider: "aws",
				},
			},
			tenantTuples: []*internal.TenantTuple{
				{
					TenantID: "tenant-X",
					Env:      "dev",
					ResourceConfig: &resource.ResourceConfig{
						Buckets: []*resource.Bucket{
							{
								Name:   "A",
								Region: "us-east-1",
							},
							{
								Name:   "B",
								Region: "us-east-1",
							},
						},
					},
				},
			},
			wantFiles: []string{
				fmt.Sprintf("/%s/tenant-X/aws-1234/us-east-1/bucket-A.yaml", TenantsOutputDir),
				fmt.Sprintf("/%s/tenant-X/aws-1234/us-east-1/bucket-B.yaml", TenantsOutputDir),
				fmt.Sprintf("/%s/tenant-X/aws-1234/us-east-1/kustomization.yaml", TenantsOutputDir),
			},
			wantFileContents: map[string]string{
				fmt.Sprintf("/%s/tenant-X/aws-1234/us-east-1/bucket-A.yaml", TenantsOutputDir): `# Code generated by kubecon-pr-generator. DO NOT EDIT.
apiVersion: s3.aws.upbound.io/v1beta1
kind: Bucket
metadata:
  name: A
spec:
  forProvider:
    region: us-east-1
  providerConfigRef:
    name: default
`,
				fmt.Sprintf("/%s/tenant-X/aws-1234/us-east-1/bucket-B.yaml", TenantsOutputDir): `# Code generated by kubecon-pr-generator. DO NOT EDIT.
apiVersion: s3.aws.upbound.io/v1beta1
kind: Bucket
metadata:
  name: B
spec:
  forProvider:
    region: us-east-1
  providerConfigRef:
    name: default
`,
				fmt.Sprintf("/%s/tenant-X/aws-1234/us-east-1/kustomization.yaml", TenantsOutputDir): `# Code generated by kubecon-pr-generator. DO NOT EDIT.
resources:
- bucket-A.yaml
- bucket-B.yaml

namePrefix: "tenant-X-aws-1234-us-east-1-"
`,
			},
		},
		{
			name: "accounts <-> tenants mapping",
			accounts: []*account.Account{
				{
					AccountID:     "1234",
					CloudProvider: "aws",
					Tags: map[string]string{
						string(key.CloudProvider): "aws",
						string(key.Env):           "prod",
					},
				},
				{
					AccountID:     "senzu-bean",
					CloudProvider: "gcp",
					Tags: map[string]string{
						string(key.CloudProvider): "gcp",
						string(key.Env):           "dev",
					},
				},
			},
			tenantTuples: []*internal.TenantTuple{
				{
					TenantID: "tenant-X",
					Env:      "dev",
					ResourceConfig: &resource.ResourceConfig{
						Buckets: []*resource.Bucket{
							{
								Name:   "A",
								Region: "us-east-1",
							},
							{
								Name:   "B",
								Region: "us-west-1",
							},
						},
					},
				},
				{
					TenantID: "tenant-Y",
					Env:      "prod",
					ResourceConfig: &resource.ResourceConfig{
						Buckets: []*resource.Bucket{
							{
								Name:   "A",
								Region: "us-east-1",
								Selector: []*selector.Requirment{
									{Key: key.CloudProvider, Operator: operator.In, Values: []string{"aws"}},
								},
							},
							{
								Name:   "B",
								Region: "us-west-1",
								Selector: []*selector.Requirment{
									{Key: key.CloudProvider, Operator: operator.In, Values: []string{"aws"}},
								},
							},
						},
					},
				},
			},
			wantFiles: []string{
				fmt.Sprintf("/%s/tenant-X/gcp-senzu-bean/us-east-1/bucket-A.yaml", TenantsOutputDir),
				fmt.Sprintf("/%s/tenant-X/gcp-senzu-bean/us-east-1/kustomization.yaml", TenantsOutputDir),
				fmt.Sprintf("/%s/tenant-X/gcp-senzu-bean/us-west-1/bucket-B.yaml", TenantsOutputDir),
				fmt.Sprintf("/%s/tenant-X/gcp-senzu-bean/us-west-1/kustomization.yaml", TenantsOutputDir),
				fmt.Sprintf("/%s/tenant-Y/aws-1234/us-east-1/bucket-A.yaml", TenantsOutputDir),
				fmt.Sprintf("/%s/tenant-Y/aws-1234/us-east-1/kustomization.yaml", TenantsOutputDir),
				fmt.Sprintf("/%s/tenant-Y/aws-1234/us-west-1/bucket-B.yaml", TenantsOutputDir),
				fmt.Sprintf("/%s/tenant-Y/aws-1234/us-west-1/kustomization.yaml", TenantsOutputDir),
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			fs := afero.NewMemMapFs()
			cg := &Codegen{
				fs: fs,
			}
			if err := cg.FanOutArtifacts(context.Background(), "/", tt.accounts, tt.tenantTuples); (err != nil) != tt.wantErr {
				t.Errorf("FanOutArtifacts() error = %v, wantErr %v", err, tt.wantErr)
				return
			}

			// Check folder structure.
			var gotFiles []string
			_ = afero.Walk(fs, "/", func(path string, info os.FileInfo, err error) error {
				if err != nil {
					return err
				}
				if info.IsDir() {
					return nil
				}
				gotFiles = append(gotFiles, path)
				return nil
			})
			if diff := cmp.Diff(tt.wantFiles, gotFiles); diff != "" {
				t.Errorf("unexpected diff on files (-want +got):\n%s", diff)
				// No need to check file contents further.
				return
			}

			for f, want := range tt.wantFileContents {
				gotBytes, err := afero.ReadFile(fs, f)
				if err != nil {
					t.Errorf("unexpected error reading file %q: %v", f, err)
					return
				}
				got := string(gotBytes)
				if diff := cmp.Diff(want, got); diff != "" {
					t.Errorf("unexpected diff on '%v' (-want +got):\n%s", f, diff)
				}
			}
		})
	}
}
